<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-time Object Detection</title>
<!-- TensorFlow.js and Custom Vision TF.js libraries -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.12.0/dist/tf.min.js"></script>
<script src="https://unpkg.com/@microsoft/customvision-tfjs@1.3.0"></script>
<!-- <link rel="stylesheet" href="style.css"> -->
<style>
    .container {
        width: 70%;
        margin: 10px auto;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    /* .btn {
        display: inline;
        margin-bottom: 5px;
    } */
    .loader {
        border: 8px solid #f3f3f3; /* Light grey */
        border-top: 8px solid #3498db; /* Blue */
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-top: 20px;
        display: none; /* Initially hidden */
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .select{
        margin-top: 20px;
    }
</style>
</head>
<body>
    <div class="container">
        <button class="btn" onclick="toggleCamera()">Toggle Camera</button>
        
        <div class="loader" id="loader"></div>
        <canvas id="canvas" style="width: 500px;"></canvas>
        <div class="select">
            <label for="videoSource">Video source: </label>
            <select id="videoSource" onchange="startDeviceDetect()"></select>
        </div>
    </div>

<script>
let videoElement;
let stream;
let running = false;

async function toggleCamera() {
    if (running) {
        stopCamera();
    } else {
        showLoader(); // Show loader while starting the camera
        await startCamera(); // Wait for camera to start
        // startDeviceDetect(); // Start detecting video devices
        // hideLoader(); // Hide loader when camera is started
    }
}

async function startCamera() {
    if (!videoElement) {
        videoElement = document.createElement('video');
        videoElement.setAttribute('autoplay', '');
        videoElement.setAttribute('playsinline', '');
    }

    const constraints = {
        video: true
    };

    try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;

        if (!document.body.contains(videoElement)) {
            // document.body.appendChild(videoElement);
            videoElement.addEventListener('loadedmetadata', () => {
                running = true;
                detectFrame();
            });
        }
    } catch (err) {
        console.error('Error accessing the camera:', err);
        hideLoader(); // Hide loader if camera access fails
    }
}

function stopCamera() {
    if (stream) {
        const tracks = stream.getTracks();
        tracks.forEach(track => track.stop());
    }
    if (videoElement && document.body.contains(videoElement)) {
        videoElement.remove();
    }

    const canvas = document.getElementById('canvas');
    if (canvas && document.body.contains(canvas)) {
        canvas.remove();
    }
    stopDetectDevice(); // Stop detecting video devices
    running = false;
}

async function detectFrame() {
    if (running) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const model = new cvstfjs.ObjectDetectionModel();
        await model.loadModelAsync('model/model.json');

        // Set canvas dimensions to match video dimensions
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;

        // Draw video frame on the canvas
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

        // Execute the object detection model on the canvas
        const result = await model.executeAsync(canvas);

        // Process the detection result
        if (result && Array.isArray(result[0]) && Array.isArray(result[1]) && Array.isArray(result[2])) {
            const boundingBoxes = result[0];
            const probabilities = result[1];
            const classIds = result[2];
            const country = ["Bangladesh", "India"]; // Define country names

            // Draw bounding boxes and labels on the canvas
            for (let i = 0; i < boundingBoxes.length; i++) {
                hideLoader();
                const [x1, y1, x2, y2] = boundingBoxes[i];
                const probability = probabilities[i];
                const classId = classIds[i];

                // Draw bounding box if probability is above threshold
                if (probability >= 0.3) {
                    const randomColor = '#' + Math.floor(Math.random() * 16777215).toString(16);
                    ctx.strokeStyle = randomColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1 * canvas.width, y1 * canvas.height, (x2 - x1) * canvas.width, (y2 - y1) * canvas.height);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = randomColor;
                    ctx.fillText(`Country Name:  ${country[classId]} (${(probability * 100).toFixed(2)}%)`, x1 * canvas.width, y1 * canvas.height - 5);
                }
            }
        } else {
            console.error('Detection result is invalid:', result);
        }

        // Call detectFrame recursively for the next frame
        requestAnimationFrame(detectFrame);
    }
}

function showLoader() {
    document.getElementById('loader').style.display = 'block';
}

function hideLoader() {
    document.getElementById('loader').style.display = 'none';
}

async function startDeviceDetect() {
    const videoSource = videoSourceSelect.value;
    const constraints = {
        video: { deviceId: videoSource ? { exact: videoSource } : undefined }
    };

    // Stop the current camera stream
    stopCamera();

    // Start camera with new constraints
    try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;
        running = true;
        detectFrame();
    } catch (err) {
        console.error('Error accessing the camera:', err);
        hideLoader(); // Hide loader if camera access fails
    }
}

function stopDetectDevice() {
    // Stop the mediaDevices enumeration
    if (videoSourceSelect) {
        videoSourceSelect.removeEventListener('change', startDeviceDetect);
    }
}
</script>

<script src="gotCamera.js"></script>

</body>
</html>
